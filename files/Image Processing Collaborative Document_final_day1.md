![](https://i.imgur.com/iywjz8s.png)

# Image Processing Collaborative Document

05-06-2023 Image Processing (day 1).

Welcome to The Workshop Collaborative Document.

This Document is synchronized as you type, so that everyone viewing this page sees the same text. This allows you to collaborate seamlessly on documents.

----------------------------------------------------------------------------

This is the Document for today: [link](<https://codimd.carpentries.org/s/6dpg_iY3n>)

Collaborative Document day 1: [link](<https://codimd.carpentries.org/s/6dpg_iY3n>)

Tiny url day 1: https://tinyurl.com/2023-06-05-dc-ip-day1

Collaborative Document day 2: [link](<https://codimd.carpentries.org/s/kCHZi2Iq3>)

Tiny url day 2: https://tinyurl.com/2023-06-06-dc-ip-day2

Repository link: https://github.com/esciencecenter-digital-skills/image-processing

Zoom link: https://tinyurl.com/imageprocessingzoom

## üëÆcode of Conduct

Participants are expected to follow these guidelines:
* Use welcoming and inclusive language.
* Be respectful of different viewpoints and experiences.
* Gracefully accept constructive criticism.
* Focus on what is best for the community.
* Show courtesy and respect towards other community members.
* button (https://esciencecenter-digital-skills.github.io/2023-06-05-dc-image-processing/)
 
## ‚öñÔ∏è License

All content is publicly available under the Creative Commons Attribution License: [creativecommons.org/licenses/by/4.0/](https://creativecommons.org/licenses/by/4.0/).

## üôãGetting help

To ask a question, just raise your hand.

If you need help from a helper, place a pink post-it note on your laptop lid. A helper will come to assist you as soon as possible.

## üñ• Workshop website

[link](<https://esciencecenter-digital-skills.github.io/2023-06-05-dc-image-processing/>)

üõ† Setup

[link](<https://github.com/esciencecenter-digital-skills/image-processing/blob/main/setup.md>)

Download files: Data files can be obtained through the repository
[link](https://github.com/esciencecenter-digital-skills/image-processing/tree/main/data)

## üë©‚Äçüè´üë©‚Äçüíªüéì Instructors

Djura Smits, Giulia Crocioni, Dani Bodor, Candace Makeda Moore

## üßë‚Äçüôã Helpers

Same as above  

## üë©‚Äçüíªüë©‚Äçüíºüë®‚Äçüî¨üßë‚Äçüî¨üßë‚ÄçüöÄüßô‚Äç‚ôÇÔ∏èüîß Roll Call
Removed for archiving purposes


## üíªüë©‚Äçüíºüî¨üë®‚Äçüî¨üßë‚Äçüî¨üöÄüîß Ice-breaker
Name: What the last good book you read?
Removed for archive purposes


## üíªüë©‚Äçüíºüî¨üë®‚Äçüî¨üßë‚Äçüî¨üöÄüîß Mini-survey
For all questions, please put your name as well

### ‚ùìüíÅ What type of images do you work on? What format(s) are these usually in?
- (example:) Dani / microscopy images / tif, nd2
- Katinka: CT, echo and MRI images / DICOM, nifti
- Marthe: Social media content (Instagram photos; YouTube videos)
- Carmen: microscopy images, tif
- Martin: Microscopy images, tif, lif
- Erik: MRI images for our neuromarketing department, various formats, also trying to work around OCR artefacts
- Daan: Microscopy images
- Xinyu: microscopy images/ tif, lif
- Noortje: mostly scans (tif,pdf) of (text) documents
- Mingshi: Cerebral MRI(T1 weighted images(T1WI) and diffusion tensor imaging(DTI)) / nifti
- Difeng: Not working on images for now but would like to learn the skill for future works (such as OCR).
- Daiqi: I'm working on Fluid Dynamics, But The pressure or velocity distribution can be treated as 3D Image or 4D Image
- Tugba: CCTV camera images and videos from pipes / png 
- Floriana: 3D images from x-ray CT

### ‚ùìüíÅ What methods or software do you currently use to analyze your images? What are the advantages and/or pitfalls of these methods?
- (example:) Dani / ImageJ / It has a nice GUI and decent built-in macro language and many pre-existing libraries for simple and medium-complexity analyses, but is buggy, slow and ultimately runs short when doing high complexity analysis.
- Carmen: ImageJ, Python. ImageJ is limited when it comes to analyse multiple images in a consistent way, and can be very slow when processing many images. Python has less packages available for image analysis.
- Marthe: Currently not analyzing visual data because I do not know how :) Programming in Python though and used to work with text analysis (e.g., SML)
- Katinka: Python
- Xinyu: Image J, python
- Daan: Image J, Fiji, I have not started using it yet. 
- Tugba: Python, Matlab
- Martin: ImageJ, Python. ImageJ is limited to automate analyses. 
- Mingshi: Python
- Noortje: python, pytesseract, challenge with image quality
- Difeng: python
- Daiqi: VMTK, actually I'm empty in image processing
- Floriana: python ( for analysis), Fiji (for visualization)

## üóìÔ∏è Agenda
| Times Day 1 | Topic                                           |
|:----------- |:----------------------------------------------- |
| 9:30        | Welcome and Intro  (Makeda)                     |
| 9:50        | Image Basics (Makeda)                           |
| 10:10       | Working with Skimage  (Makeda)                  |
| 11:00       | Coffee                                          |
| 11:15       | Drawing (Djura)                                 |
| 12:15       | Lunch                                           |
| 13:15       | Bitwise operations (Djura)                      |
| 14:30       | Creating Histograms (Djura)                     |
| 15:30       | Summary Lecture (Makeda)                        |
| 16:30       | Urgent feedback collection and updates (Makeda) |
| 16:40       | Optional extra tutoring (Makeda)                |
| 17:00       | END                                             |

| Times Day 2 | Topic                                           |
| :---------- |:----------------------------------------------- |
|        9:30 | Welcome back (Makeda)                           |
|        9:40 | Blurring Images (Giulia)                        |
|       10:30 | Coffee break                                    |
|       10:45 | Thresholding Images (Giulia)                    |
|       11:45 | Connected components analysis (Dani)            |
|       12:30 | Lunch break                                     |
|       13:30 | Optional Challenge (Dani)                       |
|       14:30 | Bonus lecture: transformations, affine (Makeda) |
|       15:30 | Feedback collection                             |
|       16:00 | Wine and networking                             |

                                   

 

## üéìüè¢ Evaluation logistics
* At the end of the day you should write evaluations into the colaborative document.


## üè¢ Location logistics
* Coffee and toilets are in the hallway, just outside of the classroom.
* If you leave the building, 
  be sure to be accompanied by someone from the escience center to let you back in through the groundfloor door
* For access to this floor you might need to ring the doorbell so someone can let you in
* In case of an emergency, you can exit our floor using the main staircase.
  Or follow green light signs at the ceiling to the emergency staircase.
* **Wifi**: Eduroam should work. Otherwise use the 'matrixbuilding' network, password should be printed out and available somewhere in the room.
    * If matrixbuilding isn't working, use the open "Amsterdam Science Park wifi"

## üéì Certificate of attendance
If you attend the full workshop you can request a certificate of attendance by emailing to training@esciencecenter.nl .

## Google collab troubleshooting
```python
from google.colab import output
output.enable_custom_widget_manager()
```
## üéìüîßEvaluations

Evaluations are anonymous, but you can also provide verbal feedback. 
 
 Evaluation | specific part or all
 -
 - Your comments| Which session or all sessions
 -
 -
 -
 -
 -
 -
 -
 -
 -
 -
 -
 

## üîß Exercises

### Exercise 1 - Image basics
Read in the eight image ("data/eight.tif") then change it into a five, and show the changed image.

#### Example Solution

```python
five = iio.imread("data/eight.tif")
five[1,2]= 1.0
five[3,0]= 1.0
fig, ax = plt.subplots()
plt.imshow(five)
print(five)
```

Skimage is numfocus and views images as numpy arrays. Knowing you have a numpy array, you can use that.

Cooordinate system explained as left hand system. Colors are made with RGB additive model. Pay attention that not every library reads RGB the same.

### Exercise 2 - Image basics
Suppose that we represent colours as triples (r, g, b), where each of r, g, and b is an integer in [0, 255] domain. What colours are represented by each of these triples?
(Try to answer these questions without reading/looking up)

(255, 0, 0) -> represents red, because the red channel is maximised, while the other two channels have the minimum values.
(0, 255, 0) -> represents green.
(0, 0, 255) -> represents blue.
(255, 255, 255) -> is a little harder. When we mix the maximum value of all three colour channels, we see the colour white.
(0, 0, 0) -> represents the absence of all colour, or black.
(128, 128, 128) -> represents a medium shade of gray. Note that the 24-bit RGB colour model provides at least 254 shades of gray, rather than only fifty.

### Exercise 3 - Working with skimage
Resize the chair image ("data/chair.jpg") to 10% of the original.

#### Example Solution

```python
chair = iio.imread(uri="data/chair.jpg")

new_shape = (chair.shape[0] // 10, chair.shape[1] // 10, chair.shape[2])
resized_chair = skimage.transform.resize(image=chair, output_shape=new_shape)
resized_chair = skimage.util.img_as_ubyte(resized_chair)

iio.imwrite(uri="data/resized_chair.jpg", image=resized_chair)

fig, ax = plt.subplots()
plt.imshow(chair)
fig, ax = plt.subplots()
plt.imshow(resized_chair)
```

### Exercise 4 - Working with skimage
Remake the sodoku image "data/sudoku.png" to be grayer.

#### Example Solution

```python
sudoku = iio.imread(uri="data/sudoku.png")
sudoku = sudoku.copy()
sudoku[sudoku > 125] = 125
fig, ax = plt.subplots()
plt.imshow(sudoku, cmap="gray", vmin=0, vmax=1)
```

### Exercise 5 - Drawing and Bitwise Operations

#### Other drawing operations
There are other functions for drawing on images, in addition to the skimage.draw.rectangle() function. We can draw circles, lines, text, and other shapes as well. These drawing functions may be useful later on, to help annotate images that our programs produce. Practice some of these functions here.

Circles can be drawn with the skimage.draw.disk() function, which takes two parameters: the (ry, cx) point of the centre of the circle, and the radius of the circle. There is an optional shape parameter that can be supplied to this function. It will limit the output coordinates for cases where the circle dimensions exceed the ones of the image.

Lines can be drawn with the skimage.draw.line() function, which takes four parameters: the (ry, cx) coordinate of one end of the line, and the (ry, cx) coordinate of the other end of the line.

Other drawing functions supported by skimage can be found in the skimage reference pages.

First let‚Äôs make an empty, black image with a size of 800x600 pixels:

```python=
# create the black canvas
image = np.zeros(shape=(600, 800, 3), dtype="uint8")
```

Now your task is to draw some other coloured shapes and lines on the image, perhaps something like this:

![](https://i.imgur.com/8U6eEAs.jpg)

#### Paste your creations below

Removed for archiving purposes

#### Example solution

Let's draw a circle:

```python
canvas = np.zeros(shape=(600, 800, 3), dtype="uint8")
rows, columns = skimage.draw.disk(center=(200, 300), radius=100, shape=canvas.shape[0:2])

canvas[rows, columns] = (0, 0, 255)

fig, ax = plt.subplots()
plt.imshow(canvas)
```

Let's add a line:

```python
rows, columns = skimage.draw.line(r0=400, c0=200, r1=500, c1=700)
canvas[rows, columns] = (0, 255, 0)
fig, ax = plt.subplots()
plt.imshow(canvas)
```

### Exercise 6 - Creating Histograms

#### Using a mask for a histogram

Looking at the histogram drawn in the lesson [Grayscale Histograms](https://codimd.carpentries.org/wTVYjOlfS2W3NeWh6vlhWg?both#Grayscale-Histograms), you will notice that there is a large number of very dark pixels, as indicated in the chart by the spike around the grayscale value 0.12. That is not so surprising, since the original image is mostly black background. What if we want to focus more closely on the leaf of the seedling? That is where a mask enters the picture!

First, hover over the plant seedling image with your mouse to determine the _(x, y)_ coordinates of a bounding box around the leaf of the seedling. Then, using techniques from the [Drawing and Bitwise Operations](https://codimd.carpentries.org/wTVYjOlfS2W3NeWh6vlhWg?both#Drawing-and-Bitwise-Operations) episode, create a mask with a white rectangle covering that bounding box.

After you have created the mask, apply it to the input image before passing it to the `np.histogram` function.


##### Example Solution

```python
# read the image as grayscale from the outset
plant_seedling = iio.imread(uri="data/plant-seedling.jpg", mode="L")

# display the image
fig, ax = plt.subplots()
plt.imshow(plant_seedling, cmap="gray")

# create mask here, using np.zeros() and skimage.draw.rectangle()
plant_mask = np.zeros(shape=plant_seedling.shape, dtype="bool")
rows, columns = skimage.draw.rectangle(start=(199, 410), end=(384, 485))
plant_mask[rows, columns] = True

# display the mask
fig, ax = plt.subplots()
plt.imshow(plant_mask, cmap="gray")

# mask the image and create the new histogram
histogram, bin_edges = np.histogram(
    plant_seedling[plant_mask],
    bins=256,
    range=(0.0, 1.0))

# configure and draw the histogram figure
plt.figure()
plt.title("Grayscale Histogram")
plt.xlabel("grayscale value")
plt.ylabel("pixel count")
plt.xlim([0.0, 1.0])
plt.plot(bin_edges[0:-1], histogram)
```

### Exercise 7 - Creating Histograms

#### Colour histogram with a mask

We can also apply a mask to the images we apply the colour histogram process to, in the same way we did for grayscale histograms. Consider this image of a well plate, where various chemical sensors have been applied to water and various concentrations of hydrochloric acid and sodium hydroxide:

```python=
# read the image
wellplate = iio.imread(uri="data/wellplate-02.tif")

# display the image
fig, ax = plt.subplots()
plt.imshow(wellplate)
```
![](https://datacarpentry.org/image-processing/fig/wellplate-02.jpg)

Suppose we are interested in the colour histogram of one of the sensors in the well plate image, specifically, the seventh well from the left in the topmost row, which shows Erythrosin B reacting with water.

Hover over the image with your mouse to find the centre of that well and the radius (in pixels) of the well. Then create a circular mask to select only the desired well. Then, use that mask to apply the colour histogram operation to that well.

Your masked image should look like this:
![](https://datacarpentry.org/image-processing/fig/wellplate-02-masked.jpg)

![](https://datacarpentry.org/image-processing/fig/wellplate-02-histogram.png)

## üß† Collaborative Notes and Command Log

### Image basics

Digital images are matrices/arrays of "picture elements" aka pixels for 2D images (or voxels for 3D images).

_Open Jupyter Lab in the image processing repository folder (run `jupyter lab` from the terminal from within the [repository](https://github.com/esciencecenter-digital-skills/image-processing) cloned on your machine) and make sure to have activated the `image_libraries` environment as indicated in the [instructions](https://github.com/esciencecenter-digital-skills/image-processing#environment)._

Let's import some useful libraries:

```python
import numpy as np
import matplotlib.pyplot as plt
import ipympl
import imageio.v3 as iio
import skimage
```

Let's load a pretty simple image.

```python
%matplotlib widget
```
If the above doesn't work, you can use the following:
```python
%matplotlib inline
```

```python
eight = iio.imread(uri="data/eight.tif")
plt.imshow(eight, cmap=plt.cm.viridis)
```

Let's print out some information about it:

```python
print(eight)
print(type(eight)) # (np.array)
print(eight.shape) # (5, 3)
```

The image changes if we default at 1 one of the values:

```python
zero = iio.imread(uri="data/eight.tif")
zero[2,1] = 1
fix, ax = plt.subplots()
plt.imshow(zero)
```

Let's plot an RGB image whose pixels are generated randomly:

```python
pseudorandomizer = np.random.RandomState(2021)
checkerboard = pseudorandomizer.randint(0, 255, size=(4,4,3))
# Note that the third dimension refers to the channels,
# here for having a RGB image we set them to 3

fig, ax = plt.subplots()
plt.imshow(checkerboard)
print(checkerboard)
```

Let's retrieve information about one of the pixels:

```python
upper_square = checkerboard[1,3,:]
upper_square # array([7,1,110]) indeed the pixel is blue-ish
```

Let's turn the image to a red-ish image by turning to 0 the Green and the Blue channels' pixels:

```python
red_channel = checkerboard*[1,0,0]
fix, ax = plt.subplots()
plt.imshow(red_channel)
```

RGB additive colour model is used in digital images and the order of the three colour values in skimage images.

Images are usually compressed, and the compression can be either lossless or lossy. Format families examples: BMP, JPEG, PNG, TIFF. 

Metadata: non-pixel/voxel data. They depend on sensor/camera and file format. 

```python
metadata = iio.immeta(uri="data/eight.tif")
metadata
```



### Working with skimage

Let's display "data/chair.jpg":

```python
import numpy as np
import matplotlib.pyplot as plt
import ipympl
import imageio.v3 as iio
import skimage
import skimage.color
import skimage.transform
import skimage.util

chair = iio.imread(uri="data/chair.jpg")
fig, ax = plt.subplots()
plt.imshow(chair)
```

```python
chair.shape # 3088, 4160, 3
```

#### Manipulating pixels

Let's display "data/maize-roots-cluster.jpg":

```python
maize_roots = iio.imread(uri="data/maize-roots-cluster.jpg")
maize_roots = np.array(maize_roots)
fig, ax = plt.subplots()
plt.imshow(maize_roots)
```

Let's put the pixels < 128 equal to 0:

```python
maize_roots[maize_roots < 128] = 0
fig, ax = plt.subplots()
plt.imshow(maize_roots)
```

#### Access via slicing

Skimage images are stored as NumPy arrays, so we can use array slicing to select rectangular areas of an image.

```python
print(maize_roots.shape) # 400, 602, 3
clipped = maize_roots[0:100, 10:60, :]
fig, ax = plt.subplots()
plt.imshow(clipped)
```

#### Lunch break! We'll be back at 13:30

### Drawing and Bitwise Operations

#### Drawing on images

```python
import numpy as np
import matplotlib.pyplot as plt
import ipympl
import imageio.v3 as iio
import skimage
import skimage.draw

%matplotlib widget

# %matplotlib inline
```

Often we wish to select only a portion of an image to analyze, and ignore the rest. Creating a rectangular sub-image with slicing is one option for simple cases. Another option is to create another special image, of the same size as the original, with white pixels indicating the region to save and black pixels everywhere else. Such an image is called a mask. In preparing a mask, we sometimes need to be able to draw a shape - a circle or a rectangle, say - on a black image. skimage provides tools to do that.

Consider this image of maize seedlings. Now, suppose we want to analyze only the area of the image containing the roots themselves; we do not care to look at the kernels, or anything else about the plants. Further, we wish to exclude the frame of the container holding the seedlings as well. Hovering over the image with our mouse, could tell us that the upper-left coordinate of the sub-area we are interested in is (44, 357), while the lower-right coordinate is (720, 740). These coordinates are shown in (x, y) order.

A Python program to create a mask to select only that area of the image would start with a now-familiar section of code to open and display the original image:

```python
# Load and display the original image
maize_seedlings = iio.imread(uri="data/maize-seedlings.tif")

fig, ax = plt.subplots()
plt.imshow(maize_seedlings)
```

NumPy allows indexing of images/arrays with ‚Äúboolean‚Äù arrays of the same size. Indexing with a boolean array is also called mask indexing. The ‚Äúpixels‚Äù in such a mask array can only take two values: `True` or `False`. When indexing an image with such a mask, only pixel values at positions where the mask is `True` are accessed. But first, we need to generate a mask array of the same size as the image:

```python
# Create the basic mask
mask = np.ones(shape=maize_seedlings.shape[0:2], dtype="bool")
```

The first argument to the ones() function is the shape of the original image, so that our mask will be exactly the same size as the original. Notice, that we have only used the first two indices of our shape. We omitted the channel dimension. Indexing with such a mask will change all channel values simultaneously. The second argument, `dtype = "bool"`, indicates that the elements in the array should be booleans - i.e., values are either `True` or `False`. Thus, even though we use `np.ones()` to create the mask, its pixel values are in fact not `1` but `True`. You could check this, e.g., by `print(mask[0, 0])`.

Next, we draw a filled, rectangle on the mask:

```python
# Draw filled rectangle on the mask image
rows, columns = skimage.draw.rectangle(start=(357, 44), end=(740, 720))
mask[rows, columns] = False
# Display mask image
fig, ax = plt.subplots()
plt.imshow(mask, cmap="gray")
```

To have more information about the method used:

```python
help(skimage.draw.rectangle)
```

The parameters of the `rectangle()` function `(357, 44)` and `(740, 720)`, are the coordinates of the upper-left (`start`) and lower-right (`end`) corners of a rectangle in (_ry, cx_) order. The function returns the rectangle as row (`rows`) and column (`columns`) coordinate arrays.

#### Image modification

All that remains is the task of modifying the image using our mask in such a way that the areas with `True` pixels in the mask are not shown in the image any more.

```python
# Load and display again the original image
maize_seedlings2 = iio.imread(uri="data/maize-seedlings.tif")

fig, ax = plt.subplots()
plt.imshow(maize_seedlings2)

# Create the basic mask
mask = np.ones(shape=maize_seedlings2.shape[0:2], dtype="bool")

rows, columns = skimage.draw.rectangle(start=(357, 44), end=(740, 720))
mask[rows, columns] = False

# Apply the mask
maize_seedlings2[mask] = 0

fig, ax = plt.subplots()
plt.imshow(maize_seedlings2)
```

##### Demo - MASKING A 96-WELL PLATE IMAGE

Consider this image of a 96-well plate that has been scanned on a flatbed scanner.

```python
# Load the image
wellplate = iio.imread(uri="data/wellplate-01.jpg")
wellplate = np.array(wellplate)

# Display the image
fig, ax = plt.subplots()
plt.imshow(wellplate)
```

Suppose that we are interested in the colours of the solutions in each of the wells. We _do not care_ about the colour of the rest of the image, i.e., the plastic that makes up the well plate itself.

We will write some code that will produce a mask that will mask out everything except for the wells. To help with this, the text file `data/centers.txt` contains the (cx, ry) coordinates of the centre of each of the 96 wells in this image. We assume that each of the wells has a radius of 16 pixels.

```python
# create the mask image
wellplate_mask = np.ones(shape=wellplate.shape[0:2], dtype="bool")

# open and iterate through the centers file...
with open("data/centers.txt", "r") as center_file:
    for line in center_file:
                ry = int(coordinates[1])
# ... getting the coordinates of each well...
        coordinates = line.split()
        cx = int(coordinates[0])
        
        # ... and drawing a circle on the mask
        rows, columns = skimage.draw.disk(center=(ry, cx), radius=16, shape=wellplate.shape[0:2])
        wellplate_mask[rows, columns] = False

# apply the mask
wellplate[wellplate_mask] = 0

# display the result
fig, ax = plt.subplots()
plt.imshow(wellplate)
```

### Creating Histograms

#### Introduction to Histograms

As it pertains to images, a _histogram_ is a graphical representation showing how frequently various colour values occur in the image. If your project involves detecting colour changes between images, histograms will prove to be very useful, and histograms are also quite handy as a preparatory step before performing thresholding (as we will see in more detail tomorrow).

#### Grayscale Histograms

We will start with grayscale images, and then move on to colour images. Here we load an image of a plant seedling in grayscale instead of full colour, and display it:

```python
import numpy as np
import matplotlib.pyplot as plt
import ipympl
import imageio.v3 as iio
import skimage
import skimage.draw
%matplotlib widget
# %matplotlib inline

# read the image of a plant seedling as grayscale from the outset
plant_seedling = iio.imread(uri="data/plant-seedling.jpg", mode="L")

# convert the image to float dtype with a value range from 0 to 1
plant_seedling = skimage.util.img_as_float(plant_seedling)

# display the image
fig, ax = plt.subplots()
plt.imshow(plant_seedling, cmap="gray")
```

Again, we use the `iio.imread()` function to load our image. Then, we convert the grayscale image of integer dtype, with 0-255 range, into a floating-point one with 0-1 range, by calling the function `skimage.util.img_as_float`. We will keep working with images in the value range 0 to 1 in this lesson.

We now use the function `np.histogram` to compute the histogram of our image which, after all, is a NumPy array:

```python
# create the histogram
histogram, bin_edges = np.histogram(plant_seedling, bins=256, range=(0, 1))
```

The parameter `bins` determines the number of ‚Äúbins‚Äù to use for the histogram. We pass in `256` because we want to see the pixel count for each of the 256 possible values in the grayscale image.

The parameter `range` is the range of values each of the pixels in the image can have. Here, we pass 0 and 1, which is the value range of our input image after transforming it to grayscale.

The first output of the `np.histogram` function is a one-dimensional NumPy array, with 256 rows and one column, representing the number of pixels with the intensity value corresponding to the index. I.e., the first number in the array is the number of pixels found with intensity value 0, and the final number in the array is the number of pixels found with intensity value 255. The second output of `np.histogram` is an array with the bin edges and one column and 257 rows (one more than the histogram itself). There are no gaps between the bins, which means that the end of the first bin, is the start of the second and so on. For the last bin, the array also has to contain the stop, so it has one more element, than the histogram.


Next, we turn our attention to displaying the histogram, by taking advantage of the plotting facilities of the `matplotlib` library.

```python
fig, ax = plt.subplots()

plt.title("Grayscale Histogram")
plt.xlabel("grayscale value")
plt.ylabel("pixel count")
plt.xlim([0.0, 1.0])  # <- named arguments do not work here

plt.plot(bin_edges[0:-1], histogram)  # <- or here
```

#### Colour Histograms

We can also create histograms for full colour images, in addition to grayscale histograms.

```python
# read original image, in full color
plant_seedling_color = iio.imread(uri="data/plant-seedling.jpg")

# display the image
fig, ax = plt.subplots()
plt.imshow(plant_seedling_color)
```

We read the original image, now in full colour, and display it.

Let's display the red channel:

```python
fig, ax = plt.subplots()
plt.imshow(plant_seedling_color[:, :, 0], cmap="gray")
```

Next, we create the histogram, by calling the `np.histogram` function three times, once for each of the channels. We obtain the individual channels, by slicing the image along the last axis. For example, we can obtain the red colour channel by calling `r_chan = image[:, :, 0]`.

```python
# tuple to select colors of each channel line
colors = ("red", "green", "blue")

# create the histogram plot, with three lines, one for
# each color
fig, ax = plt.subplots()
plt.xlim([0, 256])

for channel_id, color in enumerate(colors):
    histogram, bin_edges = np.histogram(
        plant_seedling[:, :, channel_id], bins=256, range=(0, 256)
    )
    plt.plot(bin_edges[0:-1], histogram, color=color)

plt.title("Color Histogram")
plt.xlabel("Color value")
plt.ylabel("Pixel count")
```

## üìö Resources

Resources will be added from the cheat sheet based on audience composition

scikit image documentation (transforms): 
https://scikit-image.org/docs/stable/api/skimage.transform.html#skimage.transform.resize




## üß†üìö Final tips and tops

### Tips
- Speed was a bit slow in the beginning (which totally makes sense given the usual start-up issues!), yet some additional material to work on simultaneously, would be great. 
- I had a practical question prior to the course but it was difficult to contact the organizers about it; that can be maybe a little clearer in the communication
- Some extra challenging (bonus) exercises may have been nice for some
- Setup instructions could be clearer 
- As for the preparation, one should not only download the repository but also read the README and update the environment; the latter point was not clear; this is best done with an ethernet connection, at home or in the office 
- If topics such as working with image dataset and saving to a computer can be discussed, it would be great. Could additional materials on these topics be provided?
- The notes have sometimes different variable names/typos and sometimes when you listen/or help someone it is hard to write the code too and then it's not just copy the code from the collaborative notes but you also have to check for error - i know it's hard to do parallel coding, but it's a bit hard to follow this way 
- I would want more fresh air in the room(s)

### Tops
- Very nice that you were so flexible in adjusting to the trouble with the trains and people joining late/online
- The tempo was very good; you did not go through the code you created too fast and you avoided using a lot of jargon (I have taken other workshops before were that was the case and that really demotived/scared me into doing this because I could not keep up). This made it really accessible and motivating and fun!
- Very nice that we were able to join online after the mess with the trains, hopefully travel will be smooth tomorrow!!
- We covered interesting topics, useful for image handling
- Good support system
- Did one of your workshops before, and the experience is consistently good. I like how it is organized with the collaborative documents and typing along with the instructor.
- Very nice system with the pink and green post-its and having one person doing the lecture and another walking around to help with the pink post-its. It allowed you to indicate you have a question without stopping the flow of the lecture.
- Very creative environment during drawing on the canvas, I love that part!
- Fun interactive exercises
- Amazing teachers!! <3
- Flexible and helpful instructors
- Informative and interactive exercises. Thanks!
- Great teachers and lot's of knowledge the are giving to us
- Great support and help for us that were late and lost :)